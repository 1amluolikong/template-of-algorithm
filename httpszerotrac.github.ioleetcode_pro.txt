https://zerotrac.github.io/leetcode_problem_rating/#/
https://www.yxtown.com/course/2/task/58/show


算法小知识：
1. i&-i：可以取出二进制的最低位
2. i&i-1：可以去掉二进制的最低位
3. 浮点数二分不建议直接和一个较小值比较，直接二分一个固定的次数这样不会有精度问题
4.gcd(x, y) = gcd(x, y - x ) 也就是说gcd(x + k, y + k) = gcd(x + k, y - x)
5.斐波那契数列的性质：gcd(F(i), F(j)) = F(gcd(i, j))
6.枚举调和级数的时间复杂度是nlogn
7.计算一个数x到一个数p的倍数的最短距离时可以使用(p - x % p) % p
8.计算m个数有多少排列，并且这之中有j个重复的数，总共有多少中情况，m！/j！（可重集排列数）
9.d/k上取整，等于（d + （k - d%k）%k）/k
10.两个数乘积是完全平方数，可以使用完全平方核把所有数处理了，就能枚举右维护左
11.裴蜀定理：x和y是不为零的正数，存在a和b，使得ax+by=gcd（x，y）
12.欧拉定理：a^φ(n) ≡ 1 (mod n)，当且仅当gcd（a， n）=1所以去掉a对于n来说的质因数，就可以用欧拉定理计算。φ(n) 这是欧拉函数，表示1-n中与n互质的数的数量。证明：因为逆元是a*x ≡ 1 (mod n)，又因为欧拉定理是a^φ(n) ≡ 1 (mod n)，分离出一个a，就变成a * a^(φ(n)-1) ≡ 1 (mod n)，所以逆元等于a^(φ(n)-1) mod n
13.2的逆元也可以等于（mod+1）/2
14.给定一个n位数，每个数互不相同且没有0，把所有排列的数加起来等于（n - 1）！*（n个1）*（数位和）
例如三位数就等于2！*111*（数位和）
15.返回最低位的0：(mask + 1) & ~mask
16.巴什博弈：两人从一堆总数为n的物品中轮流取物，每次取[1,m]个，最后取光者获胜。结论是 若 n 能被 m+1 整除，则先手必败，否则先手胜
17.N mod A = K 等价于 （A > K（因为余数必须小于除数），(N - K) mod A = 0（即 A 是 N-K 的约数））
18.浮点数小tips：取两个接近1但不相同的分数a/（a+1）和（a-1）/a，根据IEEE754，在使用双精度浮点数的情况下，如果这两个数的绝对差1/（a（a+1））比2^（-52）还小，那么计算机可能会把这两个数舍入到同一个附近的浮点数上。所以当a达到2^（26）约等于6.7*10^（7）的时候浮点数就不一定对了。
19.给定一个数组a，每次操作删除a中的至多两个不同元素。删除所有元素，最多要操作多少次？结论：max（（n + 1） / 2， m）。其中n是数组a的长度，m是出现次数最多的元素的出现次数